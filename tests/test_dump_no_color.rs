#![cfg(all(feature = "repr-dump", not(feature = "repr-color")))]

use pretty_assertions::assert_eq;
use wrapbin::{
    repr::dump::{dump_representation, DumpFormatOptions},
    Binary,
};

// ------------------------------------------------------------------------------------------------
// Integration Tests
// ------------------------------------------------------------------------------------------------

const LOREM_IPSUM_TEXT: &str = include_str!("lorem_ipsum_text.txt");

#[test]
fn test_dump_representation_binary() {
    const EXPECTED: &str = r##"0b       00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 │ 00001000 00001001 00001010 00001011 00001100 00001101 00001110 00001111 
         ────────────────────────────────────────────────────────────────────────│ ────────────────────────────────────────────────────────────────────────
000000:  01001100 01101111 01110010 01100101 01101101 00100000 01101001 01110000 │ 01110011 01110101 01101101 00100000 01100100 01101111 01101100 01101111 
000010:  01110010 00100000 01110011 01101001 01110100 00100000 01100001 01101101 │ 01100101 01110100 00101100 00100000 01100011 01101111 01101110 01110011 
000020:  01100101 01100011 01110100 01100101 01110100 01110101 01110010 00100000 │ 01100001 01100100 01101001 01110000 01101001 01110011 01100011 01101001 
000030:  01101110 01100111 00100000 01100101 01101100 01101001 01110100 00101100 │ 00100000 01110011 01100101 01100100 00100000 01100100 01101111 00100000 
000040:  01100101 01101001 01110101 01110011 01101101 01101111 01100100 00100000 │ 01110100 01100101 01101101 01110000 01101111 01110010 00100000 01101001 
000050:  01101110 01100011 01101001 01100100 01101001 01100100 01110101 01101110 │ 01110100 00100000 01110101 01110100 00100000 01101100 01100001 01100010 
000060:  01101111 01110010 01100101 00100000 01100101 01110100 00100000 01100100 │ 01101111 01101100 01101111 01110010 01100101 00100000 01101101 01100001 
000070:  01100111 01101110 01100001 00100000 01100001 01101100 01101001 01110001 │ 01110101 01100001 00101110 00100000 01010101 01110100 00100000 01100101 
000080:  01101110 01101001 01101101 00100000 01100001 01100100 00100000 01101101 │ 01101001 01101110 01101001 01101101 00100000 01110110 01100101 01101110 
000090:  01101001 01100001 01101101 00101100 00100000 01110001 01110101 01101001 │ 01110011 00100000 01101110 01101111 01110011 01110100 01110010 01110101 
0000A0:  01100100 00100000 01100101 01111000 01100101 01110010 01100011 01101001 │ 01110100 01100001 01110100 01101001 01101111 01101110 00100000 01110101 
0000B0:  01101100 01101100 01100001 01101101 01100011 01101111 00100000 01101100 │ 01100001 01100010 01101111 01110010 01101001 01110011 00100000 01101110 
0000C0:  01101001 01110011 01101001 00100000 01110101 01110100 00100000 01100001 │ 01101100 01101001 01110001 01110101 01101001 01110000 00100000 01100101 
0000D0:  01111000 00100000 01100101 01100001 00100000 01100011 01101111 01101101 │ 01101101 01101111 01100100 01101111 00100000 01100011 01101111 01101110 
0000E0:  01110011 01100101 01110001 01110101 01100001 01110100 00101110 00100000 │ 01000100 01110101 01101001 01110011 00100000 01100001 01110101 01110100 
0000F0:  01100101 00100000 01101001 01110010 01110101 01110010 01100101 00100000 │ 01100100 01101111 01101100 01101111 01110010 00100000 01101001 01101110 
000100:  00100000 01110010 01100101 01110000 01110010 01100101 01101000 01100101 │ 01101110 01100100 01100101 01110010 01101001 01110100 00100000 01101001 
000110:  01101110 00100000 01110110 01101111 01101100 01110101 01110000 01110100 │ 01100001 01110100 01100101 00100000 01110110 01100101 01101100 01101001 
000120:  01110100 00100000 01100101 01110011 01110011 01100101 00100000 01100011 │ 01101001 01101100 01101100 01110101 01101101 00100000 01100100 01101111 
000130:  01101100 01101111 01110010 01100101 00100000 01100101 01110101 00100000 │ 01100110 01110101 01100111 01101001 01100001 01110100 00100000 01101110 
000140:  01110101 01101100 01101100 01100001 00100000 01110000 01100001 01110010 │ 01101001 01100001 01110100 01110101 01110010 00101110 00100000 01000101 
000150:  01111000 01100011 01100101 01110000 01110100 01100101 01110101 01110010 │ 00100000 01110011 01101001 01101110 01110100 00100000 01101111 01100011 
000160:  01100011 01100001 01100101 01100011 01100001 01110100 00100000 01100011 │ 01110101 01110000 01101001 01100100 01100001 01110100 01100001 01110100 
000170:  00100000 01101110 01101111 01101110 00100000 01110000 01110010 01101111 │ 01101001 01100100 01100101 01101110 01110100 00101100 00100000 01110011 
000180:  01110101 01101110 01110100 00100000 01101001 01101110 00100000 01100011 │ 01110101 01101100 01110000 01100001 00100000 01110001 01110101 01101001 
000190:  00100000 01101111 01100110 01100110 01101001 01100011 01101001 01100001 │ 00100000 01100100 01100101 01110011 01100101 01110010 01110101 01101110 
0001A0:  01110100 00100000 01101101 01101111 01101100 01101100 01101001 01110100 │ 00100000 01100001 01101110 01101001 01101101 00100000 01101001 01100100 
0001B0:  00100000 01100101 01110011 01110100 00100000 01101100 01100001 01100010 │ 01101111 01110010 01110101 01101101 00101110 "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default().with_binary_bytes(),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_representation_octal() {
    const EXPECTED: &str = r##"0o       000 001 002 003 004 005 006 007 │ 010 011 012 013 014 015 016 017 
         ────────────────────────────────│ ────────────────────────────────
000000:  114 157 162 145 155 040 151 160 │ 163 165 155 040 144 157 154 157 
000010:  162 040 163 151 164 040 141 155 │ 145 164 054 040 143 157 156 163 
000020:  145 143 164 145 164 165 162 040 │ 141 144 151 160 151 163 143 151 
000030:  156 147 040 145 154 151 164 054 │ 040 163 145 144 040 144 157 040 
000040:  145 151 165 163 155 157 144 040 │ 164 145 155 160 157 162 040 151 
000050:  156 143 151 144 151 144 165 156 │ 164 040 165 164 040 154 141 142 
000060:  157 162 145 040 145 164 040 144 │ 157 154 157 162 145 040 155 141 
000070:  147 156 141 040 141 154 151 161 │ 165 141 056 040 125 164 040 145 
000080:  156 151 155 040 141 144 040 155 │ 151 156 151 155 040 166 145 156 
000090:  151 141 155 054 040 161 165 151 │ 163 040 156 157 163 164 162 165 
0000A0:  144 040 145 170 145 162 143 151 │ 164 141 164 151 157 156 040 165 
0000B0:  154 154 141 155 143 157 040 154 │ 141 142 157 162 151 163 040 156 
0000C0:  151 163 151 040 165 164 040 141 │ 154 151 161 165 151 160 040 145 
0000D0:  170 040 145 141 040 143 157 155 │ 155 157 144 157 040 143 157 156 
0000E0:  163 145 161 165 141 164 056 040 │ 104 165 151 163 040 141 165 164 
0000F0:  145 040 151 162 165 162 145 040 │ 144 157 154 157 162 040 151 156 
000100:  040 162 145 160 162 145 150 145 │ 156 144 145 162 151 164 040 151 
000110:  156 040 166 157 154 165 160 164 │ 141 164 145 040 166 145 154 151 
000120:  164 040 145 163 163 145 040 143 │ 151 154 154 165 155 040 144 157 
000130:  154 157 162 145 040 145 165 040 │ 146 165 147 151 141 164 040 156 
000140:  165 154 154 141 040 160 141 162 │ 151 141 164 165 162 056 040 105 
000150:  170 143 145 160 164 145 165 162 │ 040 163 151 156 164 040 157 143 
000160:  143 141 145 143 141 164 040 143 │ 165 160 151 144 141 164 141 164 
000170:  040 156 157 156 040 160 162 157 │ 151 144 145 156 164 054 040 163 
000180:  165 156 164 040 151 156 040 143 │ 165 154 160 141 040 161 165 151 
000190:  040 157 146 146 151 143 151 141 │ 040 144 145 163 145 162 165 156 
0001A0:  164 040 155 157 154 154 151 164 │ 040 141 156 151 155 040 151 144 
0001B0:  040 145 163 164 040 154 141 142 │ 157 162 165 155 056 "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default().with_octal_bytes(),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_representation_decimal() {
    const EXPECTED: &str = r##"0d       000 001 002 003 004 005 006 007 │ 008 009 010 011 012 013 014 015 
         ────────────────────────────────│ ────────────────────────────────
000000:  076 111 114 101 109 032 105 112 │ 115 117 109 032 100 111 108 111 
000010:  114 032 115 105 116 032 097 109 │ 101 116 044 032 099 111 110 115 
000020:  101 099 116 101 116 117 114 032 │ 097 100 105 112 105 115 099 105 
000030:  110 103 032 101 108 105 116 044 │ 032 115 101 100 032 100 111 032 
000040:  101 105 117 115 109 111 100 032 │ 116 101 109 112 111 114 032 105 
000050:  110 099 105 100 105 100 117 110 │ 116 032 117 116 032 108 097 098 
000060:  111 114 101 032 101 116 032 100 │ 111 108 111 114 101 032 109 097 
000070:  103 110 097 032 097 108 105 113 │ 117 097 046 032 085 116 032 101 
000080:  110 105 109 032 097 100 032 109 │ 105 110 105 109 032 118 101 110 
000090:  105 097 109 044 032 113 117 105 │ 115 032 110 111 115 116 114 117 
0000A0:  100 032 101 120 101 114 099 105 │ 116 097 116 105 111 110 032 117 
0000B0:  108 108 097 109 099 111 032 108 │ 097 098 111 114 105 115 032 110 
0000C0:  105 115 105 032 117 116 032 097 │ 108 105 113 117 105 112 032 101 
0000D0:  120 032 101 097 032 099 111 109 │ 109 111 100 111 032 099 111 110 
0000E0:  115 101 113 117 097 116 046 032 │ 068 117 105 115 032 097 117 116 
0000F0:  101 032 105 114 117 114 101 032 │ 100 111 108 111 114 032 105 110 
000100:  032 114 101 112 114 101 104 101 │ 110 100 101 114 105 116 032 105 
000110:  110 032 118 111 108 117 112 116 │ 097 116 101 032 118 101 108 105 
000120:  116 032 101 115 115 101 032 099 │ 105 108 108 117 109 032 100 111 
000130:  108 111 114 101 032 101 117 032 │ 102 117 103 105 097 116 032 110 
000140:  117 108 108 097 032 112 097 114 │ 105 097 116 117 114 046 032 069 
000150:  120 099 101 112 116 101 117 114 │ 032 115 105 110 116 032 111 099 
000160:  099 097 101 099 097 116 032 099 │ 117 112 105 100 097 116 097 116 
000170:  032 110 111 110 032 112 114 111 │ 105 100 101 110 116 044 032 115 
000180:  117 110 116 032 105 110 032 099 │ 117 108 112 097 032 113 117 105 
000190:  032 111 102 102 105 099 105 097 │ 032 100 101 115 101 114 117 110 
0001A0:  116 032 109 111 108 108 105 116 │ 032 097 110 105 109 032 105 100 
0001B0:  032 101 115 116 032 108 097 098 │ 111 114 117 109 046 "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default().with_decimal_bytes(),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_representation_upper_hex() {
    const EXPECTED: &str = r##"0X       00 01 02 03 04 05 06 07 │ 08 09 0A 0B 0C 0D 0E 0F 
         ────────────────────────│ ────────────────────────
000000:  4C 6F 72 65 6D 20 69 70 │ 73 75 6D 20 64 6F 6C 6F 
000010:  72 20 73 69 74 20 61 6D │ 65 74 2C 20 63 6F 6E 73 
000020:  65 63 74 65 74 75 72 20 │ 61 64 69 70 69 73 63 69 
000030:  6E 67 20 65 6C 69 74 2C │ 20 73 65 64 20 64 6F 20 
000040:  65 69 75 73 6D 6F 64 20 │ 74 65 6D 70 6F 72 20 69 
000050:  6E 63 69 64 69 64 75 6E │ 74 20 75 74 20 6C 61 62 
000060:  6F 72 65 20 65 74 20 64 │ 6F 6C 6F 72 65 20 6D 61 
000070:  67 6E 61 20 61 6C 69 71 │ 75 61 2E 20 55 74 20 65 
000080:  6E 69 6D 20 61 64 20 6D │ 69 6E 69 6D 20 76 65 6E 
000090:  69 61 6D 2C 20 71 75 69 │ 73 20 6E 6F 73 74 72 75 
0000A0:  64 20 65 78 65 72 63 69 │ 74 61 74 69 6F 6E 20 75 
0000B0:  6C 6C 61 6D 63 6F 20 6C │ 61 62 6F 72 69 73 20 6E 
0000C0:  69 73 69 20 75 74 20 61 │ 6C 69 71 75 69 70 20 65 
0000D0:  78 20 65 61 20 63 6F 6D │ 6D 6F 64 6F 20 63 6F 6E 
0000E0:  73 65 71 75 61 74 2E 20 │ 44 75 69 73 20 61 75 74 
0000F0:  65 20 69 72 75 72 65 20 │ 64 6F 6C 6F 72 20 69 6E 
000100:  20 72 65 70 72 65 68 65 │ 6E 64 65 72 69 74 20 69 
000110:  6E 20 76 6F 6C 75 70 74 │ 61 74 65 20 76 65 6C 69 
000120:  74 20 65 73 73 65 20 63 │ 69 6C 6C 75 6D 20 64 6F 
000130:  6C 6F 72 65 20 65 75 20 │ 66 75 67 69 61 74 20 6E 
000140:  75 6C 6C 61 20 70 61 72 │ 69 61 74 75 72 2E 20 45 
000150:  78 63 65 70 74 65 75 72 │ 20 73 69 6E 74 20 6F 63 
000160:  63 61 65 63 61 74 20 63 │ 75 70 69 64 61 74 61 74 
000170:  20 6E 6F 6E 20 70 72 6F │ 69 64 65 6E 74 2C 20 73 
000180:  75 6E 74 20 69 6E 20 63 │ 75 6C 70 61 20 71 75 69 
000190:  20 6F 66 66 69 63 69 61 │ 20 64 65 73 65 72 75 6E 
0001A0:  74 20 6D 6F 6C 6C 69 74 │ 20 61 6E 69 6D 20 69 64 
0001B0:  20 65 73 74 20 6C 61 62 │ 6F 72 75 6D 2E "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default().with_upper_hex_bytes(),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_representation_lower_hex() {
    const EXPECTED: &str = r##"0x       00 01 02 03 04 05 06 07 │ 08 09 0a 0b 0c 0d 0e 0f 
         ────────────────────────│ ────────────────────────
000000:  4c 6f 72 65 6d 20 69 70 │ 73 75 6d 20 64 6f 6c 6f 
000010:  72 20 73 69 74 20 61 6d │ 65 74 2c 20 63 6f 6e 73 
000020:  65 63 74 65 74 75 72 20 │ 61 64 69 70 69 73 63 69 
000030:  6e 67 20 65 6c 69 74 2c │ 20 73 65 64 20 64 6f 20 
000040:  65 69 75 73 6d 6f 64 20 │ 74 65 6d 70 6f 72 20 69 
000050:  6e 63 69 64 69 64 75 6e │ 74 20 75 74 20 6c 61 62 
000060:  6f 72 65 20 65 74 20 64 │ 6f 6c 6f 72 65 20 6d 61 
000070:  67 6e 61 20 61 6c 69 71 │ 75 61 2e 20 55 74 20 65 
000080:  6e 69 6d 20 61 64 20 6d │ 69 6e 69 6d 20 76 65 6e 
000090:  69 61 6d 2c 20 71 75 69 │ 73 20 6e 6f 73 74 72 75 
0000A0:  64 20 65 78 65 72 63 69 │ 74 61 74 69 6f 6e 20 75 
0000B0:  6c 6c 61 6d 63 6f 20 6c │ 61 62 6f 72 69 73 20 6e 
0000C0:  69 73 69 20 75 74 20 61 │ 6c 69 71 75 69 70 20 65 
0000D0:  78 20 65 61 20 63 6f 6d │ 6d 6f 64 6f 20 63 6f 6e 
0000E0:  73 65 71 75 61 74 2e 20 │ 44 75 69 73 20 61 75 74 
0000F0:  65 20 69 72 75 72 65 20 │ 64 6f 6c 6f 72 20 69 6e 
000100:  20 72 65 70 72 65 68 65 │ 6e 64 65 72 69 74 20 69 
000110:  6e 20 76 6f 6c 75 70 74 │ 61 74 65 20 76 65 6c 69 
000120:  74 20 65 73 73 65 20 63 │ 69 6c 6c 75 6d 20 64 6f 
000130:  6c 6f 72 65 20 65 75 20 │ 66 75 67 69 61 74 20 6e 
000140:  75 6c 6c 61 20 70 61 72 │ 69 61 74 75 72 2e 20 45 
000150:  78 63 65 70 74 65 75 72 │ 20 73 69 6e 74 20 6f 63 
000160:  63 61 65 63 61 74 20 63 │ 75 70 69 64 61 74 61 74 
000170:  20 6e 6f 6e 20 70 72 6f │ 69 64 65 6e 74 2c 20 73 
000180:  75 6e 74 20 69 6e 20 63 │ 75 6c 70 61 20 71 75 69 
000190:  20 6f 66 66 69 63 69 61 │ 20 64 65 73 65 72 75 6e 
0001A0:  74 20 6d 6f 6c 6c 69 74 │ 20 61 6e 69 6d 20 69 64 
0001B0:  20 65 73 74 20 6c 61 62 │ 6f 72 75 6d 2e "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default().with_lower_hex_bytes(),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_representation_ascii() {
    const EXPECTED: &str = r##"0X       00 01 02 03 04 05 06 07 │ 08 09 0A 0B 0C 0D 0E 0F 
         ────────────────────────│ ────────────────────────
000000:  L  o  r  e  m  20 i  p  │ s  u  m  20 d  o  l  o  
000010:  r  20 s  i  t  20 a  m  │ e  t  ,  20 c  o  n  s  
000020:  e  c  t  e  t  u  r  20 │ a  d  i  p  i  s  c  i  
000030:  n  g  20 e  l  i  t  ,  │ 20 s  e  d  20 d  o  20 
000040:  e  i  u  s  m  o  d  20 │ t  e  m  p  o  r  20 i  
000050:  n  c  i  d  i  d  u  n  │ t  20 u  t  20 l  a  b  
000060:  o  r  e  20 e  t  20 d  │ o  l  o  r  e  20 m  a  
000070:  g  n  a  20 a  l  i  q  │ u  a  .  20 U  t  20 e  
000080:  n  i  m  20 a  d  20 m  │ i  n  i  m  20 v  e  n  
000090:  i  a  m  ,  20 q  u  i  │ s  20 n  o  s  t  r  u  
0000A0:  d  20 e  x  e  r  c  i  │ t  a  t  i  o  n  20 u  
0000B0:  l  l  a  m  c  o  20 l  │ a  b  o  r  i  s  20 n  
0000C0:  i  s  i  20 u  t  20 a  │ l  i  q  u  i  p  20 e  
0000D0:  x  20 e  a  20 c  o  m  │ m  o  d  o  20 c  o  n  
0000E0:  s  e  q  u  a  t  .  20 │ D  u  i  s  20 a  u  t  
0000F0:  e  20 i  r  u  r  e  20 │ d  o  l  o  r  20 i  n  
000100:  20 r  e  p  r  e  h  e  │ n  d  e  r  i  t  20 i  
000110:  n  20 v  o  l  u  p  t  │ a  t  e  20 v  e  l  i  
000120:  t  20 e  s  s  e  20 c  │ i  l  l  u  m  20 d  o  
000130:  l  o  r  e  20 e  u  20 │ f  u  g  i  a  t  20 n  
000140:  u  l  l  a  20 p  a  r  │ i  a  t  u  r  .  20 E  
000150:  x  c  e  p  t  e  u  r  │ 20 s  i  n  t  20 o  c  
000160:  c  a  e  c  a  t  20 c  │ u  p  i  d  a  t  a  t  
000170:  20 n  o  n  20 p  r  o  │ i  d  e  n  t  ,  20 s  
000180:  u  n  t  20 i  n  20 c  │ u  l  p  a  20 q  u  i  
000190:  20 o  f  f  i  c  i  a  │ 20 d  e  s  e  r  u  n  
0001A0:  t  20 m  o  l  l  i  t  │ 20 a  n  i  m  20 i  d  
0001B0:  20 e  s  t  20 l  a  b  │ o  r  u  m  .  "##;
    let repr = dump_representation(
        &Binary::from(LOREM_IPSUM_TEXT.as_bytes()),
        &DumpFormatOptions::default()
            .with_upper_hex_bytes()
            .show_ascii(true),
    );
    assert_eq!(EXPECTED, repr);
}

#[test]
fn test_dump_ascii_extended_chart() {
    const EXPECTED: &str = r##"0X       00 01 02 03 04 05 06 07 │ 08 09 0A 0B 0C 0D 0E 0F 
         ────────────────────────│ ────────────────────────
000000:  ␀  ␁  ␂  ␃  ␄  ␅  ␆  ␇  │ ␈  ␉  ␊  ␋  ␌  ␍  ␎  ␏  
000010:  ␐  ␑  ␒  ␓  ␔  ␕  ␖  ␗  │ ␘  ␙  ␚  ␛  ␜  ␝  ␞  ␟  
000020:  ␠  !  "  #  $  %  &  '  │ (  )  *  +  ,  -  .  /  
000030:  0  1  2  3  4  5  6  7  │ 8  9  :  ;  <  =  >  ?  
000040:  @  A  B  C  D  E  F  G  │ H  I  J  K  L  M  N  O  
000050:  P  Q  R  S  T  U  V  W  │ X  Y  Z  [  \  ]  ^  _  
000060:  `  a  b  c  d  e  f  g  │ h  i  j  k  l  m  n  o  
000070:  p  q  r  s  t  u  v  w  │ x  y  z  {  |  }  ~  ␡  
000080:  80 81 82 83 84 85 86 87 │ 88 89 8A 8B 8C 8D 8E 8F 
000090:  90 91 92 93 94 95 96 97 │ 98 99 9A 9B 9C 9D 9E 9F 
0000A0:  ⍽  ¡  ¢  £  ¤  ¥  ¦  §  │ ¨  ©  ª  «  ¬  AD ®  ¯  
0000B0:  °  ±  ²  ³  ´  µ  ¶  ·  │ ¸  ¹  º  »  ¼  ½  ¾  ¿  
0000C0:  À  Á  Â  Ã  Ä  Å  Æ  Ç  │ È  É  Ê  Ë  Ì  Í  Î  Ï  
0000D0:  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  │ Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  
0000E0:  à  á  â  ã  ä  å  æ  ç  │ è  é  ê  ë  ì  í  î  ï  
0000F0:  ð  ñ  ò  ó  ô  õ  ö  ÷  │ ø  ù  ú  û  ü  ý  þ  ÿ  
"##;
    let chart = Binary::from((0u8..=255).collect::<Vec<u8>>());
    let repr = dump_representation(
        &chart,
        &DumpFormatOptions::default()
            .with_upper_hex_bytes()
            .show_extended_ascii(true),
    );
    assert_eq!(EXPECTED, repr);
}
